---
title: "Sampling & Downloading GSV Images"
author: 'Uijeong "UJ" Hwang'
date: '2025-10-27'
output:
  rmdformats::downcute:
    downcute_theme: "chaos"
---

<style type="text/css">
  body{
  font-family: Arial;
  }
</style>

# Introduction

In this module, we want to collect Google Street View (GSV) images from a city of your choice, apply a semantic segmentation model to those images, and examine how the results vary across different road types.

In this lab session, our main task is to collect the images. Specifically, we will sample points from a road network, prepare the location data (i.e., coordinates and headings), and then download the images. 

In previous studies, researchers have used various methods to determine where to sample GSV images -- for example, some sampled four images per street segment, while others downloaded panoramas every N meters.In this exercise, we will download four images per street segment. However, you will also learn an alternative sampling method at the end of the module.

**NOTE:** The method for sampling GSV images in this document is a simplified version.

![](https://raw.githubusercontent.com/ujhwang/urban-analytics-2025/main/Lab/module_4/img/GSV_sampling.JPG)

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(magrittr)
library(osmdata)
library(sfnetworks)
library(units)
library(sf)
library(tidygraph)
library(tmap)
library(here)
library(progress)
library(nominatimlite)
ttm()
```

# Step 1. Select a study area.

Choose a city you like. It can be any U.S. city, or even one anywhere in the world. One of the great advantages of using OpenStreetMap data is that its structure is consistent globally. For example, road types follow the same hierarchy everywhere: Motorway, Trunk, Primary, Secondary, Tertiary, Residential, and so on. 

I recommend picking a big city like Atlanta so that we have enough segments for each road type. Don't worry about excessive API calls -- we will be sampling only 50 rows per road type.

Just make sure that Google Maps provides GSV coverage in your chosen city.

# Step 2. Get OSM data and clean it.

## 2-1. Download OSM.

Download OSM data, convert it to an sfnetwork object, and clean it.
```{r message=F, warning=F}
# Bounding Box for the city you chose.
## Option 1 (US only)
my_bb <- tigris::places(state = ????) %>% 
  filter(NAME == ????) %>%
  st_bbox()

## Option 2: For a non-US city, `tigris` is not available. Use `nominatimlite` instead.
my_bb <- nominatimlite::geo_lite_sf(????, points_only = F)

# Get OSM data.
osm_road <- opq(bbox = ????) %>%
  add_osm_feature(key = ????, 
                  value = c("motorway", "trunk", "primary", 
                            "secondary", "tertiary", "residential")) %>%
  osmdata_sf() %>% 
  osm_poly2line()

# Convert the OSM lines to sfnetwork and clean it.
net <- osm_road$osm_lines %>% 
  select(osm_id, highway) %>% 
  sfnetworks::as_sfnetwork(directed = FALSE) %>% 
  activate(????) %>%
  filter(????) %>% # remove duplicated edges
  filter(????) %>% # remove loops
  convert(., ????) %>% # subdivide edges
  convert(., sfnetworks::to_spatial_smooth, summarise_attributes = "first") # delete pseudo nodes
```

## 2-2. Extract edges.

Extract "edges" from the cleaned road network, add a `length` column, remove short segments (less than 300 feet or 91 meters), and assign a unique ID to each edge.

To avoid excessive API calls, we will sample **50 segments per road type**, so that the total number of API calls does not exceed *1,200* (6 road types X 50 segments X 4 images per segment).

```{r}
set.seed(123) # for reproducibility
edges <- net %>% 
  # Extract 'edges'
  st_as_sf("edges") %>% 
  # Drop redundant columns 
  select(osm_id, highway) %>% 
  # Add a length column
  mutate(length = st_length(.) %>% unclass()) %>% 
  # Drop short segments (< 300 feet)
  filter(length >= 91) %>% 
  # Sample 50 rows per road type
  group_by(highway) %>% 
  slice_sample(n = 50) %>% 
  # Assign a unique ID for each edge
  ungroup() %>% 
  mutate(edge_id = seq(1,nrow(.)))

table(edges$highway)

tm_shape(edges) + tm_lines(col = "highway")
```

> Now, the total number of rows in the `edges` object multiplied by 4 is essentially the number of API calls we will make.

# Step 3. Get coordinates and headings.

We will download four images per street segment: one at the **start** of the segment, two in the **middle** (facing opposite directions), and one at the **end** of the segment.

![](https://raw.githubusercontent.com/ujhwang/urban-analytics-2025/main/Lab/module_4/img/atan.jpg)

```{r}
# Select an edge for illustration
test_edge_n <- 1
test_edge <- edges %>% 
  filter(edge_id == test_edge_n) %>% 
  st_geometry()

test_edge %>%
  with(
    tm_basemap("OpenStreetMap") +
      tm_shape(.) + tm_lines(lwd = 5, col = "red")
  )
```

## 3-1. Sample points and get azimuth.

The code below demonstrates how to extract a street segment and calculate the azimuth for the start point, end point, and midpoint. These azimuths will be used to determine the heading for each image when making API requests.

```{r}
# -----------------------------------------------------------
# First intersection: first two points from the segment
start_p <- test_edge %>% 
  st_coordinates() %>% 
  .[1:2,1:2]

# Calculate the azimuth
start_azi <- atan2(start_p[????,"X"] - start_p[????, "X"],
                   start_p[????,"Y"] - start_p[????, "Y"])*180/pi # 180/pi because trigonometry in R takes radians

# -----------------------------------------------------------
# The other intersection: last two points from the segment
end_p <- test_edge %>% 
  st_coordinates() %>% 
  .[(nrow(.)-1):nrow(.),1:2]

# Calculate the azimuth
end_azi <- atan2(end_p[????,"X"] - end_p[????, "X"],
                 end_p[????,"Y"] - end_p[????, "Y"])*180/pi

# Flip the azimuth so that the camera would be looking back
end_azi <- if (end_azi < 180) {end_azi + 180} else {end_azi - 180}

# ----------------------------------------------------------
# mid point
mid_p3 <- test_edge %>% 
  .[[1]] %>% 
  st_line_sample(sample = c(0.48, 0.5, 0.52)) %>% # 0.48 and 0.52 are for azimuth calculation
  st_cast("POINT") %>% 
  st_coordinates()

mid_p <- mid_p3[2,]

mid_azi_1 <- atan2(mid_p3[1,"X"] - mid_p3[2, "X"],
                   mid_p3[1,"Y"] - mid_p3[2, "Y"])*180/pi

mid_azi_2 <- atan2(mid_p3[3,"X"] - mid_p3[2, "X"],
                   mid_p3[3,"Y"] - mid_p3[2, "Y"])*180/pi

```

Do the azimuth values make sense?: 
<span style="color: lightblue;">`r start_azi`</span>;
<span style="color: orchid;">`r mid_azi_1`</span>;
<span style="color: green;">`r mid_azi_2`</span>;
<span style="color: pink;">`r end_azi`</span>

```{r}
tm_basemap("OpenStreetMap") + 
  tm_shape(test_edge) + tm_lines(lwd = 3) +
  tm_shape(st_linestring(start_p) %>% st_sfc(crs = 4326)) + tm_lines(col = "lightblue", lwd = 8) +
  tm_shape(st_linestring(mid_p3[1:2,]) %>% st_sfc(crs = 4326)) + tm_lines(col = "orchid", lwd = 8) +
  tm_shape(st_linestring(mid_p3[2:3,]) %>% st_sfc(crs = 4326)) + tm_lines(col = "green", lwd = 8) +
  tm_shape(st_linestring(end_p) %>% st_sfc(crs = 4326)) + tm_lines(col = "pink", lwd = 8)
```


## 3-2. Define a function.

Define a function that performs Step 3-1.
```{r}
getAzimuth <- function(line){
  # end point 1 ----------------------------------------------
  start_p <- line %>% 
  st_coordinates() %>% 
  .[1:2,1:2]

  start_azi <- atan2(start_p[????,"X"] - start_p[????, "X"],
                     start_p[????,"Y"] - start_p[????, "Y"])*180/pi
  
  # end point 2 ----------------------------------------------
  end_p <- line %>% 
    st_coordinates() %>% 
    .[(nrow(.)-1):nrow(.),1:2]
  
  end_azi <- atan2(end_p[????,"X"] - end_p[????, "X"],
                   end_p[????,"Y"] - end_p[????, "Y"])*180/pi
  
  end_azi <- if (end_azi < 180) {end_azi + 180} else {end_azi - 180}
  
  # mid point 1 ---------------------------------------------
  mid_p3 <- line %>% 
    st_line_sample(sample = c(0.48, 0.5, 0.52)) %>% 
    st_cast("POINT") %>% 
    st_coordinates()
  
  mid_p <- mid_p3[2,]
  
  mid_azi_1 <- atan2(mid_p3[1,"X"] - mid_p3[2, "X"],
                     mid_p3[1,"Y"] - mid_p3[2, "Y"])*180/pi
  
  mid_azi_2 <- atan2(mid_p3[3,"X"] - mid_p3[2, "X"],
                     mid_p3[3,"Y"] - mid_p3[2, "Y"])*180/pi
  
  # return in data frame ------------------------------------
  return(tribble(
    ~type,     ~X,             ~Y,             ~azi,
    "start",   start_p[1,"X"], start_p[1,"Y"], start_azi,
    "mid1",    mid_p["X"],     mid_p["Y"],     mid_azi_1,
    "mid2",    mid_p["X"],     mid_p["Y"],     mid_azi_2,
    "end",     end_p[2,"X"],   end_p[2,"Y"],   end_azi))
}
```

## 3-3. Apply the function to `edges`.

Apply the function to all street segments.

```{r, message=FALSE, warning=FALSE}
edges_azi <- edges %>% 
  st_geometry() %>% 
  map_df(getAzimuth, .progress = T)

edges_azi %<>% 
  bind_cols(edges %>% 
              st_drop_geometry() %>%
              slice(rep(1:nrow(edges),each=4))) %>% 
  st_as_sf(coords = c("X", "Y"), crs = 4326, remove=FALSE) %>% 
  mutate(node_id = seq(1, nrow(.)))

edges_azi
```

> Export the result `edges_azi` to a geojson file (e.g., ***edges_azi_{city_name}.geojson***) using `st_write()`. We will need this data later.

```{r}
edges_azi %>% st_write(????)
```


You may as well use the 
<a href="https://raw.githubusercontent.com/ujhwang/urban-analytics-2025/main/Lab/module_4/edges_azi_atlanta.geojson" download>Atlanta data</a> I created.
```{r eval=F}
# Download images 
edges_azi <- st_read("https://raw.githubusercontent.com/ujhwang/urban-analytics-2025/main/Lab/module_4/edges_azi_atlanta.geojson")
```

# Step 4. Get GSV images.

Now that we have prepared the data for the GSV API parameters (coordinates and headings), we can proceed to download the images.

## 4-1. Define a function.

First, we define a function that formats the request URL and downloads the images.
```{r}
getImage <- function(iterrow){
  type = iterrow$type
  location <- paste0(iterrow$Y %>% round(5), ",", iterrow$X %>% round(5))
  heading <- iterrow$azi %>% round(1)
  edge_id <- iterrow$edge_id
  node_id <- iterrow$node_id
  highway <- iterrow$highway
  key <- Sys.getenv(????) # your Google API key
  
  endpoint <- ????
  
  request <- glue::glue("{endpoint}?size=640x640&location={location}&heading={heading}&fov=90&pitch=0&key={key}")
  fname <- glue::glue("GSV-nid_{node_id}-eid_{edge_id}-type_{type}-Location_{location}-heading_{heading}-highway_{highway}.jpg")
  fpath <- ???? # Set your own directory for the downloaded images
  download.file(request, fpath, mode = 'wb')
  
  Sys.sleep(1)
}
```

## 4-2. Download the images.

Download the images for all segments using the custom function `getImage()`.  
  
<span style="color: pink; font-weight: bold;">This process can take more than 30 minutes (roughly 3 minutes per 100 images).</span>

```{r message=F}
# Create a progress bar to monitor progress
pb <- txtProgressBar(min = 0, max = nrow(edges_azi), style = 3)

# Loop through each segment to download images
for (i in seq(1,nrow(edges_azi))){
  getImage(edges_azi[i,])
  setTxtProgressBar(pb, i)
}
```

> Once all images are downloaded, **zip the folder** containing the images and name it `gsv_images.zip`. This compressed file will be used in the subsequent analysis for semantic segmentation and further processing.

# (Optional) Another way to sample points.

One of the most widely used sampling methods is to download one panoramic image at a fixed distance interval, such as every 100 meters. This can be easily implemented with a small modification to the code shown above.

In this approach, two sets of points are generated: (1) for the actual locations of the images, and (2) for the azimuth calculations. Note that the points used for azimuth calculation are twice as many as the points for the actual locations.

```{r}
# calculate what proportion equals 100 in the given segment
prop <- 100/test_edge$length

# Vector for actual points
sample_actual <- c(seq(0, 1, by=prop), 1)

# Vector for two points before/after the actual points for azimuth calculation
sample_azi <- c(sample_actual-0.02, sample_actual+0.02) %>% sort()

# Sample points
sampled_actual <- test_edge %>%
  st_transform(32616) %>% 
  st_line_sample(sample = sample_actual) %>% 
  st_cast("POINT")

sampled_azi <- test_edge %>% 
  st_transform(32616) %>% 
  st_line_sample(sample = sample_azi) %>% 
  st_cast("POINT")

tm_basemap("OpenStreetMap") + 
  tm_shape(sampled_actual) + tm_dots(fill = "blue")

# Calculate azimuth
point_azi <- sampled_actual %>%
  st_sf() %>% 
  mutate(azi = NA)

for (i in 1:nrow(point_azi)){
  j <- i*2 - 1
  point_azi[i, "azi"] <- sampled_azi %>% 
    st_cast("POINT") %>% 
    .[j:(j+1)] %>% 
    st_coordinates() %>% 
    as.data.frame() %>% 
    with(
      .[2,] - .[1,]
    ) %>% 
    with(
      atan2(.[["X"]], .[["Y"]])*180/pi
    )
}
```
